(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{616:function(t,s,a){"use strict";a.r(s);var i=a(6),v=Object(i.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"},[t._v("前言")]),a("p",[t._v("说到V8引擎，前端开发人员一定不陌生。作为最流行的JavaScript引擎，它将JavaScript的性能提升到了一个全新的水平。")]),t._v(" "),a("p",[t._v("关于V8引擎的时代背景和发展历史，在这里就不过多阐述了，有兴趣的同学可以自行了解.")])]),a("h2",{attrs:{id:"什么是v8引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是v8引擎"}},[t._v("#")]),t._v(" 什么是V8引擎?")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("首先，"),a("code",[t._v("JavaScript")]),t._v("是一门高级编程语言，所以JavaScript代码直接交给浏览器或者Node执行时，底层的CPU是不认识的，也没法执行。CPU只认识自己的指令集，指令集对应的是汇编代码。")]),t._v(" "),a("p",[t._v("汇编语言: 由于机器语言是一系列二进制代码，不方便程序员记忆、使用和阅读，所以"),a("code",[t._v("汇编语言")]),t._v("应运而生,通常高级语言需要转换成汇编语言，然后在通过编译器转换成机器语言。")])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("V8引擎是一个JavaScript引擎，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。")]),t._v(" "),a("p",[t._v("目前比较出名的js引擎有:")]),t._v(" "),a("ul",[a("li",[t._v("V8 (Google)")]),t._v(" "),a("li",[t._v("SpiderMonkey (Mozilla)")]),t._v(" "),a("li",[t._v("JavaScriptCore (Apple)")]),t._v(" "),a("li",[t._v("Chakra (Microsoft)")]),t._v(" "),a("li",[t._v("IOT：duktape、JerryScript")])]),t._v(" "),a("p",[t._v("简单来说，V8是一个接收js代码，然后进行编译执行的C++程序，编译后的代码可以在多种操作系统多种处理器上执行。")])]),a("h2",{attrs:{id:"v8引擎是如何编译js代码的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎是如何编译js代码的"}},[t._v("#")]),t._v(" V8引擎是如何编译JS代码的？")]),t._v(" "),a("h3",{attrs:{id:"_1-早期的v8引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-早期的v8引擎"}},[t._v("#")]),t._v(" 1. 早期的V8引擎")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"title"}),a("p",[t._v("早期的(5.9版本之前)V8引擎,没有解释器，但有两个编译器")])]),a("p",[t._v("它的编译流程是这样的：")]),t._v(" "),a("ul",[a("li",[t._v("首先js代码由解析器解析成AST抽象语法树")]),t._v(" "),a("li",[t._v("然后，由"),a("code",[t._v("Full-codegen")]),t._v("编译器直接使用AST编译出机器代码，没有进行任何中间转换")]),t._v(" "),a("li",[t._v("当代码运行一段时间后，V8引擎中的分析线程收集了足够的数据，帮助另一个编辑器"),a("code",[t._v("Crankshaft")]),t._v("对代码进行优化")]),t._v(" "),a("li",[t._v("需要优化的JS源码重新生成AST，然后"),a("code",[t._v("Crankshaft")]),t._v("使用AST再生成优化后的机器代码，提升运行效率")])]),t._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"title"}),a("p",[t._v("这种设计模式带来的问题：")]),t._v(" "),a("ul",[a("li",[t._v("生成的机器码会占用大量的内存空间,并且有些代码仅执行一次，没有必要直接生成机器码")]),t._v(" "),a("li",[t._v("缺少中间层字节码，很多优化策略无法实施，导致V8引擎性能提升缓慢")]),t._v(" "),a("li",[t._v("无法很好的支持JS新的语法特性，无法拥抱未来")])])]),a("h3",{attrs:{id:"_2-目前大部分的js引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-目前大部分的js引擎"}},[t._v("#")]),t._v(" 2. 目前大部分的JS引擎")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("大部分的JS引擎都会用到以下三个重要的组件")])]),a("p",[a("img",{attrs:{src:"/assets/img/V8-yinqing/p1.png",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"_2-1-解析器-parser"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-解析器-parser"}},[t._v("#")]),t._v(" 2.1 解析器(parser)")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("解析器(parser)负责将JS源代码解析成抽象语法树AST")])]),a("p",[a("img",{attrs:{src:"/assets/img/V8-yinqing/p2.png",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"_2-2-解释器-interpreter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-解释器-interpreter"}},[t._v("#")]),t._v(" 2.2 解释器(interpreter)")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("解释器(interpreter)负责将AST解释成字节码bytecode")])]),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"title"}),a("p",[t._v("需要注意的是，解释器也有直接执行字节码的能力")])]),a("p",[a("img",{attrs:{src:"/assets/img/V8-yinqing/p3.png",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"_2-3-编译器-compiler"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-编译器-compiler"}},[t._v("#")]),t._v(" 2.3 编译器(compiler)")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("编译器(compiler)负责编译出更加有效(相对于bytecode来说)的机器代码")])]),a("p",[a("img",{attrs:{src:"/assets/img/V8-yinqing/p4.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_3-现代v8引擎-改进之后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-现代v8引擎-改进之后"}},[t._v("#")]),t._v(" 3. 现代V8引擎(改进之后)")]),t._v(" "),a("h4",{attrs:{id:"_3-1-语法树的解析和之前保持一致"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-语法树的解析和之前保持一致"}},[t._v("#")]),t._v(" 3.1 语法树的解析和之前保持一致")]),t._v(" "),a("blockquote",[a("p",[t._v("JS源代码首先被解析器解析成AST抽象语法树")])]),t._v(" "),a("h4",{attrs:{id:"_3-2-引入了基准解释器-ignition-优化编译器-turbofan"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-引入了基准解释器-ignition-优化编译器-turbofan"}},[t._v("#")]),t._v(" 3.2 引入了基准解释器(Ignition),优化编译器(TurboFan)")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/V8-yinqing/p5.png",alt:""}})]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("ul",[a("li",[t._v("语法树通过"),a("code",[t._v("Ignition")]),t._v("生成了"),a("code",[t._v("bytecode")]),t._v("字节码,此时AST就被清除，释放内存空间")]),t._v(" "),a("li",[t._v("生成的bytecode直接被解释器执行，生成的bytecode相当于等效的基准基准机器代码的25%-50%作用")]),t._v(" "),a("li",[t._v("在代码运行的过程中，解释器收集到了很多可以用来优化代码的信息，然后发送给编译器"),a("code",[t._v("TurboFan")])]),t._v(" "),a("li",[a("code",[t._v("TurboFan")]),t._v("编译出经过优化的机器代码")])])]),a("h4",{attrs:{id:"_3-3-v8引擎一些简单的优化策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-v8引擎一些简单的优化策略"}},[t._v("#")]),t._v(" 3.3 V8引擎一些简单的优化策略")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("ul",[a("li",[t._v("如果函数只被声明，而未被调用，则不会生成抽象语法树AST")]),t._v(" "),a("li",[t._v("如果函数只被调用一次，bytecode会直接被解释执行，而不会生成机器代码")]),t._v(" "),a("li",[t._v("函数被调用多次，可能会被标记为热点函数，而能会被编译成机器代码")])])]),a("h4",{attrs:{id:"_3-4-deoptimization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-deoptimization"}},[t._v("#")]),t._v(" 3.4 deoptimization")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("因为JS是动态语言,有时会导致"),a("code",[t._v("Ignition")]),t._v("收集到错误的信息")]),t._v(" "),a("p",[t._v("优化后的机器代码，有时会被逆向还原成字节码")])]),a("h4",{attrs:{id:"_3-5-新的设计模式带来的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-新的设计模式带来的好处"}},[t._v("#")]),t._v(" 3.5 新的设计模式带来的好处")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("ul",[a("li",[t._v("由于不需要一开始直接编译成机器码，而是生成了中间层的字节码，bytecode的生成速度是远远大于机器码的，所以网页初始化解析执行JS的时间缩短了")]),t._v(" "),a("li",[t._v("生成优化的机器代码时，不需要从源码重新编译，而是使用字节码，而且需要"),a("code",[t._v("deoptimization")]),t._v("时，只需要回到中间层的字节码直接解释执行即可")])])]),a("h4",{attrs:{id:"_4-查看js源代码生成的字节码的命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-查看js源代码生成的字节码的命令"}},[t._v("#")]),t._v(" 4. 查看JS源代码生成的字节码的命令:")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("node "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("print"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("bytecode xxx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])])])}),[],!1,null,null,null);s.default=v.exports}}]);